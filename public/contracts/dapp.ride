{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

###
#Base variables and functions
###
#Variables
let address = "3NBdqVGWfdqV3UJ8S1xsz5qoBRGTEsLioLf"
let keyEventPrefix = "e_"
let keyEventDataPrefix = "data_"
let keyEventPricePrefix = "price_"
let keyEventDatePrefix = "date_"
let keyEventAttendeePrefix = "a_"
let keyProducerBalancePrefix = "balance_"
let keyEventAmountTicketPrefix = "amountTickets_"
let keyEventCanceledPrefix = "canceled_"
# let keyEventMaxTicketsPrefix = "max_"
let keyEventRequiresIdPrefix = "requiresId_"
let NONE = "none"

#Base read by key
func getNumberByKey(key: String) = {
    let num = match getInteger(this, key) {
        case a:Int => a
        case _ => 0
    }
    num
}
func getStrByKey(key: String) = {
    let str = match getString(this, key) {
        case a:String => a
        case _ => NONE
    }
    str
}
func getBoolByKey(key: String) = {
    let bool = match getBoolean(this, key) {
        case a:Boolean => a
        case _ => false
    }
    bool
}

###
# Getters & Setters
###
#Event Key
func getEventKey(producer: String, title: String) = {
    keyEventPrefix + toBase58String(sha256(toBytes(producer + title)))
}
#Data Key
func getEventDataKey(event: String) = {
    keyEventDataPrefix + event
}
#Price Key
func getEventPriceKey(event: String) = {
    keyEventPricePrefix + event
}
#Date Key
func getEventDateKey(event: String) = {
    keyEventDatePrefix + event
}
#Event Attendee Key
func getEventAttendeeKey(user: String, id: String, event: String) = {
    keyEventAttendeePrefix + toBase58String(sha256(toBytes(user + id))) + "_" + event
}
#Producer Balance Key
func getEventBalanceKey(account: String, event: String) = {
    keyProducerBalancePrefix + account + "_" + event
}
#Amount of Tickets Key
func getEventAmountTicketsKey(event: String) = {
    keyEventAmountTicketPrefix + event
}
#Event Canceled Key
func getEventCanceledKey(event: String) = {
    keyEventCanceledPrefix + event
}
#Event Requires personal ID Key
func getEventRequiresIdKey(event: String) = {
    keyEventRequiresIdPrefix + event
}

# Event Value => Event creator address
func getEventValueById(item: String) = {
    getStrByKey(item)
}
func getEventValue(producer: String, title: String) = {
    getStrByKey(getEventKey(producer, title))
}
# Price Value
func getEventPriceValue(event: String) = {
    getNumberByKey(getEventPriceKey(event))
}
# Date Value
func getEventDateValue(event: String) = {
    getNumberByKey(getEventDateKey(event))
}
#Event Attendee Value
func getEventAttendeeValue(user: String, id: String, event: String) = {
    getNumberByKey(getEventAttendeeKey(user, id, event))
}
#Producer Balance Value
func getEventBalanceValue(account: String, event: String) = {
    getNumberByKey(getEventBalanceKey(account, event))
}
#Amount of Tickets Value
func getEventAmountTicketsValue(event: String) = {
    getNumberByKey(getEventAmountTicketsKey(event))
}
#Event Canceled Value
func getEventCanceledValue(event: String) = {
    getBoolByKey(getEventCanceledKey(event))
}
#Event Requires personal ID Value
func getEventRequiresIdValue(event: String) = {
    getBoolByKey(getEventRequiresIdKey(event))
}



###
# Martket Callables
###
#Add Event declaration
@Callable(i)
func createEvent(title: String, price: Int, data: String, date: Int, amountTickets: Int, requiresId: Boolean) = {
    let producerAddress = toBase58String(i.caller.bytes)
    let event = getEventKey(producerAddress, title)
	
    if (getEventValue(producerAddress, title) != NONE) 
        then throw("The event already exist")
    else if (date < lastBlock.timestamp) 
        then throw("Date cannot be in the past")
    else {
        WriteSet([
            DataEntry(getEventKey(producerAddress, title), producerAddress),
            DataEntry(getEventPriceKey(event), price),
            DataEntry(getEventDataKey(event), data),
            DataEntry(getEventDateKey(event), date),
            DataEntry(getEventAmountTicketsKey(event), amountTickets),
            DataEntry(getEventRequiresIdKey(event), requiresId)
        ])
    }
}

#Purchase Item declaration
@Callable(i)
func purchase(event: String, amount: Int, id: String) = {
	let pmt = extract(i.payment)
	if (isDefined(pmt.assetId)) then throw("can use WAVES only at the moment")
	else {
		let userAddress = toBase58String(i.caller.bytes)
		let price = getEventPriceValue(event)
        let producerAddress = getEventValueById(event)
        let ticketsLeft = getEventAmountTicketsValue(event)
        let attendeeKey = ""

        ### cant buy if
        # max tickets per buyer
		if (producerAddress == NONE) 
            then throw("Event does not exist")
        else if (pmt.amount < price * amount) 
            then throw("You did not send enough money. You sent: " + pmt.amount.toString() + ". Expected: " + (amount * price).toString())
		else if (pmt.amount > price * amount) 
            then throw("You send too much money. You sent: " + pmt.amount.toString() + ". Total price: " + (amount * price).toString())
		else if ((ticketsLeft - amount) < 0 ) 
            then throw("Not enough tickets left")
        else if (getEventDateValue(event) < lastBlock.timestamp + 15000000) 
            then throw("This event has already happened")
        else if (getEventCanceledValue(event)) 
            then throw("This event was canceled")
        else if (getEventRequiresIdValue(event) && id == "")
            then throw("This event requires that you register with a personal ID")
        
        else ScriptResult(
            WriteSet([
				DataEntry(getEventAttendeeKey(userAddress, id, event), getEventAttendeeValue(userAddress, id, event) + amount),
				DataEntry(getEventBalanceKey(producerAddress, event), getEventBalanceValue(producerAddress, event) + pmt.amount),
                DataEntry(getEventAmountTicketsKey(event), ticketsLeft - amount)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(address), pmt.amount, unit)
            ])
        )
	}
}

#End ticket sale declaration
@Callable(i)
func endTicketSale(title: String) = {
    let producerAddress = toBase58String(i.caller.bytes)
    let event = getEventKey(producerAddress, title)

    if (event == "" || getEventValueById(event) != producerAddress)
        then throw("You have not created any Event yet!")
    else if (getEventCanceledValue(event))
        then throw("This event was canceled")
    else if (getEventDateValue(event) < lastBlock.timestamp) 
        then throw("This event has already happened")
    else {
        WriteSet([
            DataEntry(getEventAmountTicketsKey(event), 0)
        ])
    }
}

#Check-in Attendee Validator declaration
@Callable(i)
func checkin(event: String, attendeeAddress: String, amount: Int, id: String) = {
    let producerAddress = toBase58String(i.caller.bytes)

    if (getEventValueById(event) != producerAddress)
        then throw("This event does not exist, or you don'e have the credentials to checkin")
    else if (getEventAttendeeValue(attendeeAddress, id, event) < amount)
        then throw("You don't have enough tickets.")
    else if (getEventCanceledValue(event))
        then throw("This event was canceled. You can redeem your ticket using refundTicket function")
    #testing purposes
    #else if (getEventDateValue(event) > lastBlock.timestamp + 15000000) 
    #    then throw("This event has not yet happened")
        
    else {
        WriteSet([
            DataEntry(getEventAttendeeKey(attendeeAddress, id, event), getEventAttendeeValue(attendeeAddress,id, event) - amount)
        ])
    }
}

#Cancel Event declaration
@Callable(i)
func cancelEvent(event: String) = {
    let producerAddress = toBase58String(i.caller.bytes)

    if (getEventValueById(event) != producerAddress)
        then throw("You have not created any Event yet!")
    else if (getEventDateValue(event) < lastBlock.timestamp + 15000000)
        then throw("This event has already happened")
    else if (getEventCanceledValue(event))
        then throw("This event was already canceled")
    else {
        WriteSet([
            DataEntry(getEventCanceledKey(event), true)
        ])
    }
}

#Redeem / Refund Ticket Price declaration
@Callable(i)
func refundTicket(event: String, amount: Int, id: String) = {
    let attendeeAddress = toBase58String(i.caller.bytes)

    if (getEventValueById(event) == NONE)
        then throw("The event does not exist")
    else if (getEventAttendeeValue(attendeeAddress, id, event) < amount)
        then throw("You don't have enough registered tickets with this address")
    else if (getEventDateValue(event) < lastBlock.timestamp + 15000000)
        then throw("This event has already happened")
    else ScriptResult(
        WriteSet([
            DataEntry(getEventAttendeeKey(attendeeAddress, id, event), getEventAttendeeValue(attendeeAddress, id, event) - amount)
        ]),
        TransferSet([
            ScriptTransfer(addressFromStringValue(attendeeAddress), amount * getEventAttendeeValue(attendeeAddress, id, event), unit)
        ])
    )
}

#Producer Withdraw balance declaration
@Callable(i)
func withdraw(event: String) = {
    let producerAddress = toBase58String(i.caller.bytes)
    let balance = getEventBalanceValue(producerAddress, event)

    if (getEventValueById(event) != producerAddress)
        then throw("Event does not exist, or you don't have the credentials to perform this action")
    else if (balance <= 0)
        then throw("Insufficient balance")
    #testing purposes
    #else if (getEventDateValue(event) > lastBlock.timestamp - 1000000)
    #    then throw("Event has not yet taken place. Withdraw funds when event takes place.")
    else if (getEventCanceledValue(event))
        then throw("Event has been canceled")
    else ScriptResult(
        WriteSet([
            DataEntry(getEventBalanceKey(producerAddress, event), 0)
        ]),
        TransferSet([
            ScriptTransfer(addressFromStringValue(producerAddress), balance, unit)
        ])
    )
}
